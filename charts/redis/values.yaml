image:
  repository: redis
  tag: '3.2.5'
  pullPolicy: 'IfNotPresent'
service:
  name: redis
  type: ClusterIP
  externalPort: 6379
  internalPort: 6379
  clusterIP: '0.0.0.0'
replicas: 1
# define some sane resource requests and limitations
resources: {}
  # limits:
  #   cpu: 200m
  #   memory: 1024Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# Chart operation controls
enabled: true

# Configuration items
timeout: 60
tcpKeepalive: 300
loglevel: "notice"
password:
  secret: gitlab-redis
  key: redis-password
# Configure persistence for Redis instance
persistence:
  enabled: true

  ## postgres data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  # storageClass: "-"
  accessMode: ReadWriteOnce
  size: 5Gi

  ## If subPath is set mount a sub folder of a volume instead of the root of the volume.
  ## This is especially handy for volume plugins that don't natively support sub mounting (like glusterfs).
  ##
  subPath: ""

  ## if volumeName is set, use this existing PersistentVolume
  # volumeName:

  # Configure save points
  # https://redis.io/topics/persistence
  # - time: every X seconds
  # - writes: if at least Y keys have changed
  # If this is intentionally empty, persistence will be disabled!
  save:
    - time: 60
      writes: 1000
    - time: 300
      writes: 10
    - time: 900
      writes: 1
